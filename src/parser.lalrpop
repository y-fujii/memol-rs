// by Yasuhiro Fujii <y-fujii at mimosa-pudica.net>, under 2-clause BSD license.  
use std::*;
use std::str::FromStr;
use ast::*;
use lalrpop_util::ParseError;

grammar;

pub definition: Definition = {
	<a:definition> "score" <b:label> "=" <c:score_with> =>? {
		let mut a = a;
		match a.scores.insert( b, c ) {
			Some( _ ) => Err( ParseError::User{ error: () } ),
			None      => Ok( a ),
		}
	},
	<a:definition> "value" <b:label> "=" <c:value> =>? {
		let mut a = a;
		match a.values.insert( b, c ) {
			Some( _ ) => Err( ParseError::User{ error: () } ),
			None      => Ok( a ),
		}
	},
	=> Definition{ scores: collections::HashMap::new(), values: collections::HashMap::new() },
};

score_with: Box<Score> = {
	<a:score_with> "with" <b:r"[h-z]"> "=" <c:score_repeat> => Box::new( Score::With( a, b.chars().next().unwrap(), c ) ),
	<a:score_with> "with" "_"          "=" <c:score_repeat> => Box::new( Score::With( a, '_',                       c ) ),
	<score_repeat>                                          => <>,
};

score_repeat: Box<Score> = {
	<a:uint> <b:score_prim> => Box::new( Score::Sequence( (0 .. a).map( |_| b.clone() ).collect() ) ),
	<score_prim>            => <>,
};

score_prim: Box<Score> = {
	<label>                 => Box::new( Score::Variable( <> ) ),
	"[" <score_list> "]"    => Box::new( Score::Sequence( <> ) ),
	"(" <score_list> ")"    => Box::new( Score::Parallel( <> ) ),
	"{" <score_content> "}" => Box::new( Score::Score( <> ) ),
};

score_list: Vec<Box<Score>> = {
	<a:score_list> <b:score_with> => { let mut a = a; a.push( b ); a },
	                              => Vec::new(),
};

score_content: Vec<Box<Note>> = {
	<a:score_content> "|" <b:group_content> => { let mut a = a;          a.push( Box::new( Note::Group( b ) ) ); a },
	                      <b:group_content> => { let mut a = Vec::new(); a.push( Box::new( Note::Group( b ) ) ); a },
};

note: Box<Note> = {
	"_"                                                     => Box::new( Note::Rest ),
	"/"                                                     => Box::new( Note::Repeat ),
	                      <a:pitch_lower> <b:key_signature> => Box::new( Note::Note( Dir::Lower,         a.0, a.1, b ) ),
	                      <a:pitch_upper> <b:key_signature> => Box::new( Note::Note( Dir::Upper,         a.0, a.1, b ) ),
	"$" <a:key_signature> <b:pitch_lower> <c:key_signature> => Box::new( Note::Note( Dir::Absolute( a ), b.0, b.1, c ) ),
	"$" <a:key_signature> <b:pitch_upper> <c:key_signature> => Box::new( Note::Note( Dir::Absolute( a ), b.0, b.1, c ) ),
	"[" <group_content> "]"                                 => Box::new( Note::Group( <> ) ),
	"(" <chord_content> ")"                                 => Box::new( Note::Chord( <> ) ),
	<note> "^"                                              => Box::new( Note::Tie( <> ) ),
};

octave: Box<Note> = {
	"<" => { Box::new( Note::Octave(  1 ) ) },
	">" => { Box::new( Note::Octave( -1 ) ) },
};

key_signature: i32 = {
	"+" <key_signature> => <> + 1,
	"-" <key_signature> => <> - 1,
	                    => 0,
};

group_content: Vec<(Box<Note>, i32)> = {
	<a:group_content>          <b:note> => { let mut a = a; a.push( (b, 1) ); a },
	<a:group_content> <c:uint> <b:note> => { let mut a = a; a.push( (b, c) ); a },
	<a:group_content> <b:octave>        => { let mut a = a; a.push( (b, 0) ); a },
	                                    => Vec::new(),
};

chord_content: Vec<Box<Note>> = {
	<a:chord_content> <b:note>   => { let mut a = a; a.push( b ); a },
	<a:chord_content> <b:octave> => { let mut a = a; a.push( b ); a },
	                             => Vec::new(),
};

value: Box<Value> = {
	=> Box::new( Value::Rest ),
};

pitch_lower: (char, i32) = {
	<a:r"[a-g]">          => ('_', a.chars().next().unwrap() as i32 - 'a' as i32),
	<a:r"[h-z]"> <b:sint> => (a.chars().next().unwrap(), b),
};

pitch_upper: (char, i32) = {
	<a:r"[A-G]">          => ('_', a.chars().next().unwrap() as i32 - 'A' as i32),
	<a:r"[H-Z]"> <b:sint> => (a.chars().next().unwrap().to_lowercase().next().unwrap(), b),
};

sint: i32 = {
	"-" <uint> => -<>,
	"+" <uint> =>  <>,
	    <uint> =>  <>,
};

uint: i32 = {
	r"[0-9]+" => i32::from_str( <> ).unwrap(),
};

label: String = {
	r"'[a-zA-Z0-9_]+" => String::from( &<>[1..] ),
};
