// (c) Yasuhiro Fujii <http://mimosa-pudica.net>, under MIT License.
use std::*;
use std::str::FromStr;
use lalrpop_util::ParseError;
use misc;
use ratio;
use ast::*;

#[LALR]
grammar<'a>( path: &path::Path );

extern {
	type Error = misc::Error;
}

pub definition: Definition<'a> = {
	<a:definition> <lo:@L> "score" <b:label> "(" ")" "=" <c:score_with> =>? {
		let mut a = a;
		match a.scores.insert( b, (path.to_owned(), c) ) {
			Some( _ ) => Err( ParseError::User{ error: misc::Error::new( path, lo, "duplicated definition." ) } ),
			None      => Ok( a ),
		}
	},
	<a:definition> <lo:@L> "value" <b:label> "(" ")" "=" <c:value_track> =>? {
		let mut a = a;
		match a.values.insert( b, (path.to_owned(), c) ) {
			Some( _ ) => Err( ParseError::User{ error: misc::Error::new( path, lo, "duplicated definition." ) } ),
			None      => Ok( a ),
		}
	},
	<a:definition> <lo:@L> "import" <b:str> =>? {
		let cpath = match path.parent() {
			Some( v ) => v.join( b ),
			None      => path::PathBuf::from( b ),
		};
		let def = parse( &cpath )
			.map_err( |e| ParseError::User{ error: e } )?;
		let mut a = a;
		a.scores.extend( def.scores );
		a.values.extend( def.values );
		Ok( a )
	},
	=> Definition{ scores: collections::HashMap::new(), values: collections::HashMap::new() },
};

score_with: Box<Ast<Score<'a>>> = {
	<lo:@L> <a:score_with> "with" <b:r"[h-z]"> "=" <c:score_prim> <hi:@R> =>
		Ast::new_box( lo, hi, Score::With( a, b.chars().next().unwrap(), c ) ),
	<lo:@L> <a:score_with> "with" "_" "=" <c:score_prim> <hi:@R> =>
		Ast::new_box( lo, hi, Score::With( a, '_', c ) ),
	<score_prim>,
};

score_prim: Box<Ast<Score<'a>>> = {
	<lo:@L> "_" <hi:@R> =>
		Ast::new_box( lo, hi, Score::Score( vec![ Ast::new_box( lo, hi, Note::Rest ) ] ) ),
	<lo:@L> <a:label> "(" ")" <hi:@R> =>
		Ast::new_box( lo, hi, Score::Symbol( a ) ),
	<lo:@L> "[" <a:score_list> "]" <hi:@R> =>
		Ast::new_box( lo, hi, Score::Sequence( a ) ),
	<lo:@L> "(" <a:score_list> ")" <hi:@R> =>
		Ast::new_box( lo, hi, Score::Parallel( a ) ),
	<lo:@L> "{" <a:score_content> "}" <hi:@R> =>
		Ast::new_box( lo, hi, Score::Score( a ) ),
	<lo:@L> "repeat" <a:uint> <b:score_prim> <hi:@R> =>
		Ast::new_box( lo, hi, Score::Repeat( b, a ) ),
	<lo:@L> "stretch" <a:sratio> <b:score_prim> <hi:@R> =>
		Ast::new_box( lo, hi, Score::Stretch( b, a ) ),
};

score_list: Vec<Box<Ast<Score<'a>>>> = {
	<a:score_list> <b:score_with> => {
		let mut a = a;
		a.push( b );
		a
	},
	=> Vec::new(),
};

score_content: Vec<Box<Ast<Note<'a>>>> = {
	<a:score_content> "|" <lo:@L> <b:group_content> <hi:@R> => {
		let mut a = a;
		a.push( Ast::new_box( lo, hi, Note::Group( b ) ) );
		a
	},
	<lo:@L> <b:group_content> <hi:@R> => {
		let mut a = Vec::new();
		a.push( Ast::new_box( lo, hi, Note::Group( b ) ) );
		a
	},
};

note: Box<Ast<Note<'a>>> = {
	<lo:@L> "_" <hi:@R> =>
		Ast::new_box( lo, hi, Note::Rest ),
	<lo:@L> "/" <hi:@R> =>
		Ast::new_box( lo, hi, Note::Repeat( cell::Cell::new( None ) ) ),
	<lo:@L> <a:pitch_lower> <b:key_signature> <hi:@R> =>
		Ast::new_box( lo, hi, Note::Note( Dir::Lower, a.0, a.1, b ) ),
	<lo:@L> <a:pitch_upper> <b:key_signature> <hi:@R> =>
		Ast::new_box( lo, hi, Note::Note( Dir::Upper, a.0, a.1, b ) ),
	<lo:@L> "[" <a:group_content> "]" <hi:@R> =>
		Ast::new_box( lo, hi, Note::Group( a ) ),
	<lo:@L> "(" <a:chord_content> ")" <hi:@R> =>
		Ast::new_box( lo, hi, Note::Chord( a ) ),
	<lo:@L> <a:note> "^" <hi:@R> =>
		Ast::new_box( lo, hi, Note::Tie( a ) ),
};

octave: Box<Ast<Note<'a>>> = {
	<lo:@L> "<" <hi:@R> =>
		Ast::new_box( lo, hi, Note::Octave(  1 ) ),
	<lo:@L> ">" <hi:@R> =>
		Ast::new_box( lo, hi, Note::Octave( -1 ) ),
	<lo:@L> "@" <a:pitch_lower> <b:key_signature> <hi:@R> =>
		Ast::new_box( lo, hi, Note::OctaveByNote( a.0, a.1, b ) ),
	<lo:@L> "@" <a:pitch_upper> <b:key_signature> <hi:@R> =>
		Ast::new_box( lo, hi, Note::OctaveByNote( a.0, a.1, b ) ),
};

key_signature: i32 = {
	"+" <key_signature> => <> + 1,
	"-" <key_signature> => <> - 1,
	                    => 0,
};

group_content: Vec<(Box<Ast<Note<'a>>>, i32)> = {
	<a:group_content> <b:note> => {
		let mut a = a;
		a.push( (b, 1) );
		a
	},
	<a:group_content> <c:uint> ":" <b:note> => {
		let mut a = a;
		a.push( (b, c) );
		a
	},
	<a:group_content> <c:uint> <b:note> => {
		let mut a = a;
		a.push( (b, c) );
		a
	},
	<a:group_content> <b:octave> => {
		let mut a = a;
		a.push( (b, 0) );
		a
	},
	=> Vec::new(),
};

chord_content: Vec<Box<Ast<Note<'a>>>> = {
	<a:chord_content> <b:note> => {
		let mut a = a;
		a.push( b );
		a
	},
	<a:chord_content> <b:octave> => {
		let mut a = a;
		a.push( b );
		a
	},
	=> Vec::new(),
};

value_track: Box<Ast<ValueTrack>> = {
	<value_track_or_wz_if>,
	<value_track_or_wo_if>,
};

value_track_or_wz_if: Box<Ast<ValueTrack>> = {
	<lo:@L> <a:value_track_or_wo_if> "||" <b:value_track_and_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Or ) ),
	<value_track_and_wz_if>,
};

value_track_or_wo_if: Box<Ast<ValueTrack>> = {
	<lo:@L> <a:value_track_or_wo_if> "||" <b:value_track_and_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Or ) ),
	<value_track_and_wo_if>,
};

value_track_and_wz_if: Box<Ast<ValueTrack>> = {
	<lo:@L> <a:value_track_and_wo_if> "&&" <b:value_track_cmp_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Mul ) ),
	<value_track_cmp_wz_if>,
};

value_track_and_wo_if: Box<Ast<ValueTrack>> = {
	<lo:@L> <a:value_track_and_wo_if> "&&" <b:value_track_cmp_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Mul ) ),
	<value_track_cmp_wo_if>,
};

value_track_cmp_wz_if: Box<Ast<ValueTrack>> = {
	<lo:@L> <a:value_track_cmp_wo_if> "==" <b:value_track_add_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Eq ) ),
	<lo:@L> <a:value_track_cmp_wo_if> "!=" <b:value_track_add_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Ne ) ),
	<lo:@L> <a:value_track_cmp_wo_if> "<=" <b:value_track_add_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Le ) ),
	<lo:@L> <a:value_track_cmp_wo_if> ">=" <b:value_track_add_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Ge ) ),
	<lo:@L> <a:value_track_cmp_wo_if> "<" <b:value_track_add_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Lt ) ),
	<lo:@L> <a:value_track_cmp_wo_if> ">" <b:value_track_add_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Gt ) ),
	<value_track_add_wz_if>,
};

value_track_cmp_wo_if: Box<Ast<ValueTrack>> = {
	<lo:@L> <a:value_track_cmp_wo_if> "==" <b:value_track_add_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Eq ) ),
	<lo:@L> <a:value_track_cmp_wo_if> "!=" <b:value_track_add_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Ne ) ),
	<lo:@L> <a:value_track_cmp_wo_if> "<=" <b:value_track_add_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Le ) ),
	<lo:@L> <a:value_track_cmp_wo_if> ">=" <b:value_track_add_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Ge ) ),
	<lo:@L> <a:value_track_cmp_wo_if> "<" <b:value_track_add_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Lt ) ),
	<lo:@L> <a:value_track_cmp_wo_if> ">" <b:value_track_add_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Gt ) ),
	<value_track_add_wo_if>,
};

value_track_add_wz_if: Box<Ast<ValueTrack>> = {
	<lo:@L> <a:value_track_add_wo_if> "+" <b:value_track_mul_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Add ) ),
	<lo:@L> <a:value_track_add_wo_if> "-" <b:value_track_mul_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Sub ) ),
	<value_track_mul_wz_if>,
};

value_track_add_wo_if: Box<Ast<ValueTrack>> = {
	<lo:@L> <a:value_track_add_wo_if> "+" <b:value_track_mul_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Add ) ),
	<lo:@L> <a:value_track_add_wo_if> "-" <b:value_track_mul_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Sub ) ),
	<value_track_mul_wo_if>,
};

value_track_mul_wz_if: Box<Ast<ValueTrack>> = {
	<lo:@L> <a:value_track_mul_wo_if> "*" <b:value_track_prim_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Mul ) ),
	<lo:@L> <a:value_track_mul_wo_if> "/" <b:value_track_prim_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Div ) ),
	<value_track_prim_wz_if>,
};

value_track_mul_wo_if: Box<Ast<ValueTrack>> = {
	<lo:@L> <a:value_track_mul_wo_if> "*" <b:value_track_prim_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Mul ) ),
	<lo:@L> <a:value_track_mul_wo_if> "/" <b:value_track_prim_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( a, b, BinaryOp::Div ) ),
	<value_track_prim_wo_if>,
};

value_track_prim_wz_if: Box<Ast<ValueTrack>> = {
	<lo:@L> "stretch" <a:sratio> <b:value_track_prim_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::Stretch( b, a ) ),
	<lo:@L> "repeat" <a:uint> <b:value_track_prim_wz_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::Repeat( b, a ) ),
	<lo:@L> "if" <a:value_track> "then" <b:value_track> "else" <c:value_track> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::Branch( a, b, c ) ),
	<lo:@L> "!" <a:value_track_prim_wz_if> <hi:@R> => {
		let one = Ast::new_box( lo, hi, ValueTrack::ValueTrack(
			vec![ Ast::new_box( lo, hi, Value::Value( ratio::Ratio::one(), ratio::Ratio::one() ) ) ]
		) );
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( one, a, BinaryOp::Sub ) )
	}
};

value_track_prim_wo_if: Box<Ast<ValueTrack>> = {
	<lo:@L> <a:uint> <hi:@R> => {
		let v = ratio::Ratio::new( a as i64, 1 );
		Ast::new_box( lo, hi, ValueTrack::ValueTrack(
			vec![ Ast::new_box( lo, hi, Value::Value( v, v ) ) ]
		) )
	},
	<lo:@L> <a:label> "(" ")" <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::Symbol( a ) ),
	<lo:@L> "[" <a:value_track_list> "]" <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::Sequence( a ) ),
	"(" <a:value_track> ")" =>
		a,
	<lo:@L> "{" <a:value_track_content> "}" <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::ValueTrack( a ) ),
	<lo:@L> "stretch" <a:sratio> <b:value_track_prim_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::Stretch( b, a ) ),
	<lo:@L> "repeat" <a:uint> <b:value_track_prim_wo_if> <hi:@R> =>
		Ast::new_box( lo, hi, ValueTrack::Repeat( b, a ) ),
	<lo:@L> "!" <a:value_track_prim_wo_if> <hi:@R> => {
		let one = Ast::new_box( lo, hi, ValueTrack::ValueTrack(
			vec![ Ast::new_box( lo, hi, Value::Value( ratio::Ratio::one(), ratio::Ratio::one() ) ) ]
		) );
		Ast::new_box( lo, hi, ValueTrack::BinaryOp( one, a, BinaryOp::Sub ) )
	}
};

value_track_list: Vec<Box<Ast<ValueTrack>>> = {
	<a:value_track_list> <b:value_track> => {
		let mut a = a;
		a.push( b );
		a
	},
	=> Vec::new(),
};

value_track_content: Vec<Box<Ast<Value>>> = {
	<a:value_track_content> "|" <lo:@L> <b:value_group_content> <hi:@R> => {
		let mut a = a;
		a.push( Ast::new_box( lo, hi, Value::Group( b ) ) );
		a
	},
	<lo:@L> <b:value_group_content> <hi:@R> => {
		let mut a = Vec::new();
		a.push( Ast::new_box( lo, hi, Value::Group( b ) ) );
		a
	},
};

value: Box<Ast<Value>> = {
	<lo:@L> <a:sratio> <hi:@R> =>
		Ast::new_box( lo, hi, Value::Value( a, a ) ),
	<lo:@L> <a:sratio> ".." <b:sratio> <hi:@R> =>
		Ast::new_box( lo, hi, Value::Value( a, b ) ),
	<lo:@L> "[" <a:value_group_content> "]" <hi:@R> =>
		Ast::new_box( lo, hi, Value::Group( a ) ),
};

value_group_content: Vec<(Box<Ast<Value>>, i32)> = {
	<a:value_group_content> <b:value> => {
		let mut a = a;
		a.push( (b, 1) );
		a
	},
	<a:value_group_content> <c:uint> ":" <b:value> => {
		let mut a = a;
		a.push( (b, c) );
		a
	},
	=> Vec::new(),
};

pitch_lower: (char, i32) = {
	<a:r"[a-g]">          => ('_', a.chars().next().unwrap() as i32 - 'a' as i32),
	<a:r"[h-z]"> <b:sint> => (a.chars().next().unwrap(), b),
};

pitch_upper: (char, i32) = {
	<a:r"[A-G]">          => ('_', a.chars().next().unwrap() as i32 - 'A' as i32),
	<a:r"[H-Z]"> <b:sint> => (a.chars().next().unwrap().to_lowercase().next().unwrap(), b),
};

sratio: ratio::Ratio = {
	<a:sint> "/" <b:uint> =>
		ratio::Ratio::new( a as i64, b as i64 ),
	<a:sint> =>
		ratio::Ratio::new( a as i64, 1 ),
};

sint: i32 = {
	"-" <uint> => -<>,
	"+" <uint> =>  <>,
	    <uint> =>  <>,
};

uint: i32 = {
	r"[0-9]+" => i32::from_str( <> ).unwrap(),
};

label: String = {
	r"\$[a-zA-Z0-9_.]+" => String::from( &<>[1 ..] ),
};

str: String = {
	<lo:@L> <a:r#""(\\n|\\r|\\t|\\\\|[^\\"])*""#> =>? {
		let mut dst = String::new();
		let mut it = a[1 .. a.len() - 1].chars();
		while let Some( c ) = it.next() {
			dst.push( if c == '\\' {
				match it.next() {
					Some( 'n'  ) => '\n',
					Some( 'r'  ) => '\r',
					Some( 't'  ) => '\t',
					Some( '\\' ) => '\\',
					_ => panic!(),
				}
			}
			else {
				c
			} );
		}
		Ok( dst )
	},
};
